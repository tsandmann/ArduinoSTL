/*	Copyright (C) 2005 Garrett A. Kajmowicz

	This file is part of the uClibc++ Library.
	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include <basic_definitions>
#include <exception>
#include <memory>
#include <char_traits>

#ifndef __HEADER_TYPE_TRAITS
#define __HEADER_TYPE_TRAITS 1

#pragma GCC visibility push(default)

namespace std {

	struct _UCXXEXPORT __true_type{};
	struct _UCXXEXPORT __false_type{};

	template <class I> class _UCXXEXPORT __is_integer{
	public:
		typedef __false_type value;
	};

	template <> class _UCXXEXPORT __is_integer <unsigned int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <signed int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <short unsigned int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <short signed int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <char>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <signed char>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <unsigned char>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <long unsigned int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <long signed int>{
	public:
		typedef __true_type value;
	};


	/* std::conditional<> */
	template <bool _Bp, class _If, class _Then>
	struct _UCXXEXPORT conditional { typedef _If type; };

	template <class _If, class _Then>
	struct _UCXXEXPORT conditional<false, _If, _Then> { typedef _Then type; };

	template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;


	/* integral_constant */
	template<typename _Tp, _Tp __v>
	struct integral_constant {
		static constexpr _Tp value = __v;
		typedef _Tp value_type;
		typedef integral_constant<_Tp, __v> type;
		constexpr operator value_type() const {
			return value;
		}
#if __cplusplus > 201103L
#define __cpp_lib_integral_constant_callable 201304
		constexpr value_type operator()() const {
			return value;
		}
#endif
	};

	template<typename _Tp, _Tp __v>
	constexpr _Tp integral_constant<_Tp, __v>::value;

	/// The type used as a compile-time boolean with true value.
	typedef integral_constant<bool, true> true_type;

	/// The type used as a compile-time boolean with false value.
	typedef integral_constant<bool, false> false_type;

	template<bool __v>
	using __bool_constant = integral_constant<bool, __v>;

#if __cplusplus > 201402L
#define __cpp_lib_bool_constant 201505
	template<bool __v>
	using bool_constant = integral_constant<bool, __v>;
#endif


	/* std::is_same */
	template<typename, typename >
	struct is_same: public false_type {
	};

	template<typename _Tp>
	struct is_same<_Tp, _Tp> : public true_type {
	};


	/* std::enable_if */
	template<bool, typename _Tp = void>
	struct enable_if {
	};

	// Partial specialization for true.
	template<typename _Tp>
	struct enable_if<true, _Tp> {
		typedef _Tp type;
	};

} /* namespace std */

#pragma GCC visibility pop

#endif // __HEADER_TYPE_TRAITS

